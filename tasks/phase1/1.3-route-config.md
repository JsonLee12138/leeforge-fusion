# ä»»åŠ¡ 1.3: è·¯ç”±é…ç½®ç®¡ç†

## åŸºæœ¬ä¿¡æ¯

- **ä»»åŠ¡ç¼–å·**: 1.3
- **Phase**: 1 - æ ¸å¿ƒè·¯ç”±ç³»ç»Ÿ
- **è´Ÿè´£äºº**: èµ„æ·±æ¶æ„å¸ˆ
- **é¢„è®¡å·¥æ—¶**: 1 å¤©
- **ä¼˜å…ˆçº§**: ğŸ”´ P0
- **ä¾èµ–**: æ— 

## ä»»åŠ¡æè¿°

å®ç°è·¯ç”±ç›¸å…³çš„é…ç½®ç®¡ç†ï¼Œæ”¯æŒç”¨æˆ·è‡ªå®šä¹‰è·¯ç”±è¡Œä¸ºã€‚

## äº¤ä»˜ç‰©

### 1. æ ¸å¿ƒæ–‡ä»¶

- `packages/framework/src/config/route-config.ts` - è·¯ç”±é…ç½®å®šä¹‰
- `packages/framework/src/config/validate.ts` - é…ç½®éªŒè¯
- `packages/framework/src/config/defaults.ts` - é»˜è®¤é…ç½®

### 2. åŠŸèƒ½è¦æ±‚

- [ ] è·¯ç”±åŸºç¡€é…ç½®
- [ ] è·¯ç”±ç»„æ˜ å°„é…ç½®
- [ ] è·¯ç”±å®ˆå«é…ç½®
- [ ] é…ç½®éªŒè¯
- [ ] é…ç½®åˆå¹¶ç­–ç•¥
- [ ] TypeScript ç±»å‹æ”¯æŒ

### 3. é…ç½®ç¤ºä¾‹

```typescript
// framework.config.ts
import { defineConfig } from "@leeforge/framework";

export default defineConfig({
  routes: {
    base: "/",
    trailingSlash: "never",
    groups: {
      "(dashboard)": "/dashboard",
      "(admin)": "/admin",
      "(api)": "/api",
    },
    guards: {
      "/admin/*": "./middleware/auth.ts",
      "/dashboard/*": "./middleware/dashboard.ts",
    },
  },
});
```

## æŠ€æœ¯è¦æ±‚

### é…ç½®ç±»å‹å®šä¹‰

```typescript
// packages/framework/src/config/route-config.ts
export interface RouteConfig {
  base?: string;
  trailingSlash?: "never" | "always";
  groups?: Record<string, string>;
  guards?: Record<string, string>;
  ignore?: string[];
}

export interface ResolvedRouteConfig extends RouteConfig {
  base: string;
  trailingSlash: "never";
  groups: Record<string, string>;
  guards: Record<string, string>;
  ignore: string[];
}
```

### é…ç½®éªŒè¯

```typescript
// packages/framework/src/config/validate.ts
export function validateRouteConfig(config: RouteConfig): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  if (config.base && !config.base.startsWith("/")) {
    errors.push("base must start with /");
  }

  if (
    config.trailingSlash &&
    !["never", "always"].includes(config.trailingSlash)
  ) {
    errors.push('trailingSlash must be "never" or "always"');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
```

### é…ç½®åˆå¹¶

```typescript
// packages/framework/src/config/merge.ts
export function mergeRouteConfig(
  base: RouteConfig,
  override: RouteConfig,
): ResolvedRouteConfig {
  return {
    ...defaults,
    ...base,
    ...override,
    groups: { ...defaults.groups, ...base.groups, ...override.groups },
    guards: { ...defaults.guards, ...base.guards, ...override.guards },
    ignore: [...(base.ignore || []), ...(override.ignore || [])],
  };
}
```

## å®ç°æ€è·¯

```typescript
// packages/framework/src/config/route-config.ts
export class RouteConfigManager {
  private config: ResolvedRouteConfig;

  constructor(config?: RouteConfig) {
    this.config = this.resolveConfig(config || {});
  }

  private resolveConfig(config: RouteConfig): ResolvedRouteConfig {
    // éªŒè¯
    const validation = validateRouteConfig(config);
    if (!validation.valid) {
      throw new Error(`Invalid route config: ${validation.errors.join(", ")}`);
    }

    // åˆå¹¶é»˜è®¤å€¼
    return {
      base: config.base || "/",
      trailingSlash: config.trailingSlash || "never",
      groups: config.groups || {},
      guards: config.guards || {},
      ignore: config.ignore || [],
    };
  }

  getGroupPath(group: string): string | undefined {
    return this.config.groups[group];
  }

  shouldIgnore(path: string): boolean {
    return this.config.ignore.some((pattern) => minimatch(path, pattern));
  }

  getGuard(path: string): string | undefined {
    for (const [pattern, guard] of Object.entries(this.config.guards)) {
      if (minimatch(path, pattern)) {
        return guard;
      }
    }
    return undefined;
  }
}
```

## æµ‹è¯•ç”¨ä¾‹

```typescript
// tests/unit/config/route-config.test.ts
describe("RouteConfigManager", () => {
  test("uses defaults when no config provided", () => {
    const manager = new RouteConfigManager();
    expect(manager.config.base).toBe("/");
    expect(manager.config.trailingSlash).toBe("never");
  });

  test("merges custom config correctly", () => {
    const manager = new RouteConfigManager({
      base: "/app",
      groups: { "(dashboard)": "/dashboard" },
    });
    expect(manager.config.base).toBe("/app");
    expect(manager.getGroupPath("(dashboard)")).toBe("/dashboard");
  });

  test("validates config", () => {
    expect(() => {
      new RouteConfigManager({ base: "invalid" });
    }).toThrow();
  });
});
```

## éªŒæ”¶æ ‡å‡†

- [ ] é…ç½®ç±»å‹å®Œæ•´
- [ ] éªŒè¯é€»è¾‘æ­£ç¡®
- [ ] åˆå¹¶ç­–ç•¥æ¸…æ™°
- [ ] é»˜è®¤é…ç½®åˆç†
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] é”™è¯¯ä¿¡æ¯å‹å¥½

## ç›¸å…³æ–‡æ¡£

- [é…ç½®ç³»ç»Ÿè®¾è®¡](../design-doc.md#é…ç½®æ–‡ä»¶)
- [è·¯ç”±ç³»ç»Ÿè®¾è®¡](../design-doc.md#1-è·¯ç”±ç³»ç»Ÿ)

---

**åˆ›å»ºæ—¶é—´**: 2026-01-15  
**æœ€åæ›´æ–°**: 2026-01-15  
**çŠ¶æ€**: å¾…å¼€å§‹
